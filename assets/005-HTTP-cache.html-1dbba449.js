import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as d,c as r,a,b as e,e as t,f as s}from"./app-94c9bffb.js";const p={},i=s(`<p>对于一些相同的请求，通过复用以前获取的资源，显著提高网页的性能。Web 缓存减少了等待时间和流量，因此减少了显示资源的渲染时间。</p><p>HTTP 缓存的实现有两种方式，分别是<strong>强制缓存</strong>和<strong>协商缓存</strong>。</p><h2 id="强缓存" tabindex="-1"><a class="header-anchor" href="#强缓存" aria-hidden="true">#</a> 强缓存</h2><p>强缓存是指：只要浏览器判断缓存没有过期，则直接使用本地缓存，不会向服务器发送请求。</p><p>强缓存是利用下面这两个字段实现的，它们都用来表示资源在客户端缓存的有效期。</p><ul><li><code>Expires</code>：绝对时间；</li><li><code>Cache-Control</code>：缓存指令。</li></ul><h3 id="expires" tabindex="-1"><a class="header-anchor" href="#expires" aria-hidden="true">#</a> Expires</h3><p>响应头包含的日期时间，在这个时间前，浏览器都不会再发起请求，而是直接使用缓存资源。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token literal-property property">Expires</span><span class="token operator">:</span> Wed<span class="token punctuation">,</span> <span class="token number">21</span> Oct <span class="token number">2015</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">28</span><span class="token operator">:</span><span class="token number">00</span> <span class="token constant">GMT</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="cache-control" tabindex="-1"><a class="header-anchor" href="#cache-control" aria-hidden="true">#</a> Cache-Control</h3><p>通用消息头字段，通过指定指令来实现缓存机制。缓存指令是单向的，这意味着在请求中设置的指令，不一定被包含在响应中。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>Cache<span class="token operator">-</span>Control<span class="token operator">:</span> max<span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">20000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>max-age=&lt;seconds&gt;</code> 可以设置过期时间（单位秒），相对于请求的时间计算。</p><p>具体流程：</p><ol><li>当浏览器第一次向服务器发起请求时，服务器响应头会带上 <code>Cache-Control</code>，其中设置了过期时间 <code>max-age</code>；</li><li>浏览器再次向服务器发起请求后，会计算<strong>当前请求时间和过期时间</strong>差值，来判断是否过期，如果过期则重新请求服务器，否则使用本地缓存；</li><li>如果已经过期，服务器再次收到请求后，会更新响应头的 <code>Cache-Control</code>。</li></ol>`,15),l=a("code",null,"max-age",-1),h={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control",target:"_blank",rel:"noopener noreferrer"},u=s(`<h3 id="优先级" tabindex="-1"><a class="header-anchor" href="#优先级" aria-hidden="true">#</a> 优先级</h3><p>当同时有 <code>Expires</code> 和 <code>Cache-Control</code> 字段时，如果 <code>Cache-Control</code> 响应头设置了 <code>max-age</code> 或 <code>s-maxage</code> 指令，那么 <code>Expires</code> 会被忽略。</p><h2 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a> 协商缓存</h2><p>为了知道服务器有没有更新内容，必须和服务器沟通，然后根据服务器返回的信息判断是否使用本地缓存，这种方式称为<strong>协商缓存</strong>。</p><p>协商缓存通过两种头部实现：</p><ul><li>请求头部的 <code>If-Modified-Since</code> 和响应头部的 <code>Last-Modified</code>；</li><li>请求头部的 <code>If-None-Match</code> 和响应头部的 <code>ETag</code>。</li></ul><h3 id="if-modified-since-和-last-modified" tabindex="-1"><a class="header-anchor" href="#if-modified-since-和-last-modified" aria-hidden="true">#</a> <code>If-Modified-Since</code> 和 <code>Last-Modified</code></h3><p>这种方式是基于时间实现的。</p><p>响应头 <code>Last-Modified</code> 存放的是资源最后修改时间：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>Last<span class="token operator">-</span>Modified<span class="token operator">:</span> Wed<span class="token punctuation">,</span> <span class="token number">21</span> Oct <span class="token number">2015</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">28</span><span class="token operator">:</span><span class="token number">00</span> <span class="token constant">GMT</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请求头中的 <code>If-Modified-Since</code> 含义为资源从xxx时间后是否有更新：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>If<span class="token operator">-</span>Modified<span class="token operator">-</span>Since<span class="token operator">:</span> Wed<span class="token punctuation">,</span> <span class="token number">21</span> Oct <span class="token number">2015</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">28</span><span class="token operator">:</span><span class="token number">00</span> <span class="token constant">GMT</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当服务器收到浏览器这个请求头后，会跟当前版本的时间进行比较：</p><ol><li>当前版本的修改时间比这个晚，也就是内容发生变化了，那么会返回 200 和新的内容；</li><li>若当前版本的修改时间较早，也就是没有更新，那么会返回 304，浏览器会从缓存中读取内容。</li></ol><h3 id="etag-和-if-none-match" tabindex="-1"><a class="header-anchor" href="#etag-和-if-none-match" aria-hidden="true">#</a> <code>ETag</code> 和 <code>If-None-Match</code></h3><p>这种方式是通过唯一标识实现。</p><p><code>ETag</code> 是资源的特定版本的标识符，响应头会根据返回内容返回一个标识符，具体返回值看服务器的计算策略，可能如下所示：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token literal-property property">ETag</span><span class="token operator">:</span> <span class="token string">&quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当客户端收到这个响应后，会将这个 <code>ETag</code> 保存起来，等下个请求时，会将它放到请求体的 <code>If-None-Match</code> 字段中：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>If<span class="token operator">-</span>None<span class="token operator">-</span>Match<span class="token operator">:</span> <span class="token string">&quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当服务器收到浏览器这个请求头后，会跟当前版本的 <code>ETag</code> 进行比较：</p><ol><li>如果标识符不一致，也就是内容发生变化了，那么会返回 200 和新的内容；</li><li>如果标识符一致，也就是没有更新，那么会返回 304，浏览器会从缓存中读取内容。</li></ol><h3 id="优先级-1" tabindex="-1"><a class="header-anchor" href="#优先级-1" aria-hidden="true">#</a> 优先级</h3><p>协商缓存先检查上一次响应头中是否有 <code>ETag</code>，如果有，则发起请求中请求头带上 <code>If-None-Match</code> 字段；如果没有，则检查上一次响应头中是否有 <code>Last-Modified</code> 字段，发起请求中请求头带上 <code>If-Modified-Since</code> 字段。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>HTTP 缓存机制分为两种：强缓存和协商缓存。</p><p>浏览器会首先判断强缓存，如果强缓存生效，那么直接从缓存中获取资源；若没有生效，则会使用协商缓存，发送请求与服务器协商。</p>`,27);function m(f,g){const n=c("ExternalLinkIcon");return d(),r("div",null,[i,a("p",null,[e("除了 "),l,e(" 外，还有其他指令，详见 "),a("a",h,[e("Cache-Control"),t(n)]),e("。")]),u])}const b=o(p,[["render",m],["__file","005-HTTP-cache.html.vue"]]);export{b as default};
